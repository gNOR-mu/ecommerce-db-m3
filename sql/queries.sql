-- -- Búsqueda de productos por nombre y por categoría.
CREATE OR REPLACE FUNCTION FIND_PRODUCT_BY_NAME_AND_CATEGORY (IN P_NAME VARCHAR(40), IN C_NAME VARCHAR(25)) 
RETURNS TABLE (ID INTEGER, CATEGORY_ID INTEGER, NAME VARCHAR, PRICE DECIMAL) 
AS $$
BEGIN
	RETURN QUERY
	SELECT P.ID, P.CATEGORY_ID,P.NAME, P.PRICE
	FROM PRODUCTS P
	JOIN CATEGORIES C ON P.CATEGORY_ID = C.ID
	WHERE P.NAME = P_NAME
	AND C.NAME = C_NAME;
END;
$$ LANGUAGE PLPGSQL;

SELECT ID, CATEGORY_ID, NAME, PRICE
FROM FIND_PRODUCT_BY_NAME_AND_CATEGORY ('Parka invierno', 'Ropa');

-- Top N productos por ventas (cantidad o monto).
--TOP X VENTAS POR MONTO
CREATE OR REPLACE FUNCTION BEST_SELLERS(IN P_QUANTITY INTEGER)
RETURNS TABLE (NAME VARCHAR, TOTAL NUMERIC)
AS $$
BEGIN
	RETURN QUERY
	SELECT P.NAME, SUM(OI.SUB_TOTAL) AS TOTAL
	FROM PRODUCTS P
	JOIN ORDERS_ITEM OI ON OI.PRODUCT_ID = P.ID
	JOIN ORDERS O ON OI.ORDER_ID = O.ID
	JOIN PAYMENTS ON O.PAYMENT_ID = PAYMENTS.ID
	WHERE PAID = TRUE
	GROUP BY P.NAME
	ORDER BY TOTAL DESC
	LIMIT P_QUANTITY;
END;
$$ LANGUAGE PLPGSQL;

SELECT NAME, TOTAL FROM BEST_SELLERS(3);

-- TOP VENTAS POR CANTIDAD
CREATE OR REPLACE FUNCTION BEST_SELLERS_AMOUNT(IN P_QUANTITY INTEGER)
RETURNS TABLE (NAME VARCHAR, TOTAL BIGINT)
AS $$
BEGIN
	RETURN QUERY
	SELECT P.NAME, SUM(QUANTITY) AS TOTAL
	FROM PRODUCTS P
	JOIN ORDERS_ITEM OI ON OI.PRODUCT_ID = P.ID
	JOIN ORDERS O ON OI.ORDER_ID = O.ID
	JOIN PAYMENTS ON O.PAYMENT_ID = PAYMENTS.ID
	WHERE PAID = TRUE
	GROUP BY P.NAME
	ORDER BY TOTAL DESC
	LIMIT P_QUANTITY;
END;
$$ LANGUAGE PLPGSQL;

SELECT NAME, TOTAL FROM BEST_SELLERS_AMOUNT(3);

-- Ventas por mes y por categoría (sumas y conteos).
SELECT
	TO_CHAR(P.PAYDAY, 'YYYY-MM') AS MONTH,
	C.NAME AS CATEGORY,
	SUM(SUB_TOTAL) AS TOTAL,
	COUNT(OI.QUANTITY) AS ORDERS_ITEM_COUNT
FROM
	ORDERS O
	JOIN PAYMENTS P ON P.ID = O.PAYMENT_ID
	JOIN ORDERS_ITEM OI ON OI.ORDER_ID = O.ID
	JOIN PRODUCTS ON PRODUCTS.ID = OI.PRODUCT_ID
	JOIN CATEGORIES C ON PRODUCTS.CATEGORY_ID = C.ID
WHERE
	P.PAID = TRUE
GROUP BY
	TO_CHAR(P.PAYDAY, 'YYYY-MM'),
	C.NAME;

-- Ticket promedio en rango de fechas.
CREATE OR REPLACE FUNCTION TICKET_AVG_RANGE (IN START_DATE DATE, IN END_DATE DATE) RETURNS TABLE (DATE_RANGE TEXT, AVERAGE DECIMAL) AS $$
BEGIN
	RETURN QUERY
	SELECT 
	FORMAT('%s - %s', START_DATE, END_DATE)::TEXT,
	AVG(O.TOTAL)
	FROM ORDERS O
	JOIN PAYMENTS P ON O.PAYMENT_ID= P.ID
	WHERE PAID = TRUE
		AND P.PAYDAY >= START_DATE
		AND P.PAYDAY <= END_DATE;
END;
$$ LANGUAGE PLPGSQL;

SELECT
	*
FROM
	TICKET_AVG_RANGE ('2023-10-01', '2023-12-27');
	
-- Stock bajo (umbral configurable)
CREATE OR REPLACE FUNCTION PRODUCTS_WITH_LOW_STOCK (IN THRESHOLD INTEGER)
RETURNS TABLE (NAME VARCHAR, QUANTITY INTEGER)
AS $$
BEGIN
	RETURN QUERY 
	SELECT P.NAME, I.QUANTITY
	FROM PRODUCTS P
	JOIN INVENTORY I ON P.ID = I.PRODUCT_ID
	WHERE I.QUANTITY <= THRESHOLD;
END;
$$ LANGUAGE PLPGSQL;

SELECT NAME, QUANTITY FROM PRODUCTS_WITH_LOW_STOCK(19);

-- Productos sin ventas.
SELECT
	P.ID,
	P.CATEGORY_ID,
	P.NAME,
	P.PRICE
FROM
	PRODUCTS P
	LEFT JOIN (
		-- excluir productos con ventas
		SELECT DISTINCT
			OI.PRODUCT_ID
		FROM
			ORDERS_ITEM OI
			JOIN ORDERS O ON OI.ORDER_ID = O.ID
			JOIN PAYMENTS PAY ON O.PAYMENT_ID = PAY.ID
		WHERE
			PAY.PAID = TRUE
	) AS V ON P.ID = V.PRODUCT_ID
WHERE
	V.PRODUCT_ID IS NULL;
    
-- Clientes frecuentes (≥ X órdenes).
CREATE OR REPLACE FUNCTION FREQUENT_CUSTOMERS(IN O_NUMBER INTEGER)
RETURNS TABLE (ID INTEGER, NAME VARCHAR, QUANTITY BIGINT)
AS $$
BEGIN
	RETURN QUERY 
	SELECT C.ID, C.NAME, COUNT (C.ID) AS QUANTITY
	FROM CUSTOMERS C
	JOIN ORDERS O ON O.CUSTOMER_ID = C.ID
	GROUP BY C.ID
	HAVING COUNT (C.ID) >= O_NUMBER;
END;
$$ LANGUAGE PLPGSQL;

SELECT ID, NAME, QUANTITY FROM FREQUENT_CUSTOMERS(2);
-- Cualquier consulta que estime relevante para su proyecto.

-- Crear una orden e insertar todos sus ítems en una sola operación, y recalcular el total de la orden al finalizar.
-- Crear una orden e insertar todos sus ítems en una sola operación, y recalcular el total de la orden al finalizar.
DO $$
DECLARE
	NEW_ORDER_ID INTEGER;
	PRODUCT_PRICE DECIMAL;

	NEW_PRODUCTS_CURSOR REFCURSOR;
	NEW_PRODUCT RECORD;
BEGIN
	-- CREACIÓN INICIAL DE LA ORDEN
	INSERT INTO ORDERS (CUSTOMER_ID) VALUES(1) RETURNING ID INTO NEW_ORDER_ID;

	-- INSERCIÓN DE DATOS
	INSERT INTO ORDERS_ITEM (ORDER_ID, PRODUCT_ID, PRICE, QUANTITY)
	SELECT
		NEW_ORDER_ID,
		P.ID,
		P.PRICE,
		6
	FROM PRODUCTS P
	WHERE P.ID = 1;

	-- INSERCIÓN DE DATOS
	INSERT INTO ORDERS_ITEM (ORDER_ID, PRODUCT_ID, PRICE, QUANTITY)
	SELECT
		NEW_ORDER_ID,
		P.ID,
		P.PRICE,
		3
	FROM PRODUCTS P
	WHERE P.ID = 3;

	-- INSERCIÓN DE DATOS
	INSERT INTO ORDERS_ITEM (ORDER_ID, PRODUCT_ID, PRICE, QUANTITY)
	SELECT
		NEW_ORDER_ID,
		P.ID,
		P.PRICE,
		2
		FROM PRODUCTS P
	WHERE P.ID = 4;

	-- ACTUALIZACIÓN DEL TOTAL DE LA ORDEN
	UPDATE ORDERS 
	SET TOTAL = (SELECT SUM(SUB_TOTAL) FROM ORDERS_ITEM WHERE ORDER_ID = NEW_ORDER_ID)
	WHERE ID = NEW_ORDER_ID;

	-- QUITA ELEMENTOS DEL INVENTARIO
	-- 1 ABRE EL CURSOR
	OPEN NEW_PRODUCTS_CURSOR FOR
		SELECT PRODUCT_ID, QUANTITY FROM ORDERS_ITEM WHERE ORDER_ID = NEW_ORDER_ID;

	-- ITERA EL CURSOR
	LOOP 
		FETCH NEW_PRODUCTS_CURSOR INTO NEW_PRODUCT; 
		EXIT WHEN NOT FOUND;
			-- ACTUALIZA EL INVENTARIO
			UPDATE INVENTORY
			SET QUANTITY = QUANTITY - NEW_PRODUCT.QUANTITY
			WHERE PRODUCT_ID = NEW_PRODUCT.PRODUCT_ID;
	END LOOP;

COMMIT;	
END;
$$ LANGUAGE PLPGSQL;